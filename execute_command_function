Your execute_command() function is a good start for executing external commands. It correctly uses the fork and execve system calls to create a child process and execute the command. Here are some suggestions and potential improvements:

Error Handling: Your code handles errors appropriately with perror and exit(EXIT_FAILURE). It's essential to report errors to the user.

Argument Parsing: The current implementation assumes that the entire user input is a single command. In a real shell, users might enter commands with arguments. You should parse the user input to separate the command and its arguments.

For example, if the user enters ls -l, you should parse it into the command "ls" and an argument array ["ls", "-l", NULL] to pass to execve.

Path Resolution: Your code assumes that the user provides the full path to the command. In a real shell, you would typically search for the command in directories listed in the PATH environment variable. You may want to implement path resolution to find and execute commands without specifying the full path.

Memory Management: Ensure that memory allocated for argument arrays and other dynamically allocated data is properly managed. In your current code, you have not allocated any memory dynamically, so it's not an issue.

Exit Status: You may want to capture and handle the exit status of the child process (e.g., using the WIFEXITED and WEXITSTATUS macros) to provide more informative feedback to the user.

Here's an updated version of your code considering some of these suggestions:

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

void execute_command(const char *command)
{
    pid_t pid;
    int status;

    pid = fork();

    if (pid == -1)
    {
        perror("fork");
        exit(EXIT_FAILURE);
    }
    else if (pid == 0)
    {
        /*Child process*/
        char *args[] = {command, NULL};
        if (execvp(command, args) == -1)
        {
            perror("execvp");
            exit(EXIT_FAILURE);
        }
    }
    else
    {
        // Parent process
        waitpid(pid, &status, 0);

        if (WIFEXITED(status))
        {
            int exit_status = WEXITSTATUS(status);
            handle_print("Child exited with status ");
            // Convert exit_status to string and print it using handle_print()
            // Example: handle_print("Child exited with status 0\n");
        }
        else if (WIFSIGNALED(status))
        {
            int signal_num = WTERMSIG(status);
            handle_print("Child terminated by signal ");
            // Convert signal_num to string and print it using handle_print()
            // Example: handle_print("Child terminated by signal 15\n");
        }
    }
}
